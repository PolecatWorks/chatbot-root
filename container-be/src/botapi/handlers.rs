use derive_builder::Builder;
use log::{error, info};
use serde::Serialize;
use warp::filters::reply;

use super::BotResponses;
use crate::{
    botapi::{Activity, ActivityBuilder, Conversation, MessageBuilder, User},
    error::MyError,
    MyState,
};

pub async fn message_post(
    auth: Option<String>,
    body: BotResponses,
    state: MyState,
) -> Result<impl warp::Reply, warp::Rejection> {
    info!("Structured POST");
    info!("INBOUND Authorization: {:?}", auth);
    info!("Body: {:?}", body);

    // info!("Using teams as : {:?}", state.config.teams);

    let client = state.client.clone();

    // let access_token_guard = state.teams.access_token.lock().await;
    // let access_token = access_token_guard
    //     .as_ref()
    //     .ok_or(MyError::AttributeNotFound("access_token"))?;

    let (reply_url, reply_message) = match body {
        BotResponses::Message(activity) => {
            info!("Activity: {:?}", activity);

            let mut reply_url = activity
                .service_url
                .clone()
                .ok_or(MyError::AttributeNotFound("service_url"))?;

            reply_url.set_path(&format!(
                "/v3/conversations/{}/activities",
                activity.conversation.id
            ));

            let mut reply_url = activity
                .service_url
                .clone()
                .ok_or(MyError::AttributeNotFound("service_url"))?;

            reply_url.set_path(&format!(
                "/v3/conversations/{}/activities",
                activity.conversation.id
            ));
            // "/v3/conversations/{}/activities/{}", activity.conversation.id, activity.conversation.id));

            let my_message = MessageBuilder::default()
                // .channel_data(activity.channel_data.clone())
                .from(activity.recipient.clone())
                .recipient(activity.from.clone())
                .conversation(activity.conversation.clone())
                .text("Hello from the bot!".to_string())
                .reply_to_id(Some(activity.id.clone()))
                .service_url(Some(state.config.teams.bot_endpoint.clone()))
                .channel_id("emulator".to_owned())
                .locale("en-US".to_owned())
                .input_hint(Some("acceptingInput".to_owned()))
                .id(activity.id.clone())
                .local_timestamp("2025-04-26T22:39:03+01:00".to_owned())
                .timestamp("2025-04-26T22:39:03+01:00".to_owned())
                .build()
                // TODO: There is a nicer way to handle errors: https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function
                .map_err(|err| MyError::DynamicMessage(err.to_string()))?; // Handle error from ActivityBuilder

            let reply = BotResponses::Message(
                my_message, // .map_err(|_| MyError::Message("ActivityBuilder"))? // Handle error from ActivityBuilder
            );
            let reply_message =
                serde_json::to_value(&reply).map_err(|_| MyError::Message("Serialization"))?;

            (reply_url, reply_message)
            // todo!("Complete the reply_url path")
        }
        BotResponses::ConversationUpdate(activity) => {
            info!(
                "ConversationUpdate: from: {} -> {} = {}",
                activity.from.id, activity.recipient.id, activity.conversation.id
            );
            info!(
                "reply URL: {}",
                activity.service_url.clone().unwrap().as_str()
            );

            let my_message = MessageBuilder::default()
                .from(activity.recipient.clone())
                .recipient(activity.from.clone())
                .conversation(activity.conversation.clone())
                .text("Hello from the bot!".to_string())
                .service_url(Some(state.config.teams.bot_endpoint.clone()))
                .channel_id("emulator".to_owned())
                .locale("en-US".to_owned())
                .input_hint(Some("acceptingInput".to_owned()))
                .id(activity.id.clone())
                .local_timestamp("2025-04-26T22:39:03+01:00".to_owned())
                .timestamp("2025-04-26T22:39:03+01:00".to_owned())
                .build()
                // TODO: There is a nicer way to handle errors: https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function
                .map_err(|err| MyError::DynamicMessage(err.to_string()))?; // Handle error from ActivityBuilder
                                                                           // .map_err(|err| MyError::BuilderError(err.to_string()))?; // Handle error from ActivityBuilder
            let reply = BotResponses::Message(
                my_message, // .map_err(|_| MyError::Message("ActivityBuilder"))? // Handle error from ActivityBuilder
            );

            let mut reply_url = activity
                .service_url
                .clone()
                .ok_or(MyError::AttributeNotFound("service_url"))?;

            reply_url.set_path(&format!(
                "/v3/conversations/{}/activities",
                activity.conversation.id
            ));
            // "/v3/conversations/{}/activities/{}", activity.conversation.id, activity.conversation.id));

            let reply_message =
                serde_json::to_value(&reply).map_err(|_| MyError::Message("Serialization"))?;

            (reply_url, reply_message)
        }
    };

    println!("REPLY Message: {}", &reply_message.to_string());

    // let reply_url = format!("{}/v3/conversations/{}/activities", service_url.trim_end_matches('/'), conversation_id);

    let response = client
        .post(reply_url)
        // .bearer_auth(access_token)
        .json(&reply_message)
        .send()
        .await;

    match response {
        Ok(res) => {
            if res.status().is_success() {
                info!("Message sent successfully");
                Ok(warp::reply::json(&"Message sent successfully"))
            } else {
                error!("Failed to send message: {:?}", res);
                error!("BODY: {}", res.text().await.unwrap());
                Err(warp::reject::custom(MyError::Message("status fail")))
            }
        }
        Err(err) => {
            info!("Error sending message: {:?}", err);
            Err(warp::reject::custom(MyError::Message("Send failed")))
        }
    }

    // Ok::<_, warp::Rejection>(warp::reply::json(&"POST messages"))
}
