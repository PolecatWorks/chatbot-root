use std::sync::Arc;

use log::{error, info};

use crate::{botapi::dl_apis::DlApis, error::MyError, MyState};

use super::directline::{BotActivity, MessageBuilder};

pub async fn message_post(
    auth: Option<String>,
    body: BotActivity,
    state: MyState,
) -> Result<impl warp::Reply, warp::Rejection> {
    info!("Structured POST");
    info!("INBOUND Authorization: {:?}", auth);
    info!("Body: {:?}", body);

    // info!("Using teams as : {:?}", state.config.teams);

    let client = state.client.clone();

    match &body {
        BotActivity::ConversationUpdate(activity) => {
            info!(
                "ConversationUpdate: from: {} -> {} = {}",
                activity.from.id, activity.recipient.id, activity.conversation.id
            );
            info!(
                "service URL: {}",
                activity.service_url.clone().unwrap().as_str()
            );

            let my_message = MessageBuilder::default()
                .from(activity.recipient.clone())
                .text("Hello from the bot!".to_string())
                .locale(Some("en-US".to_owned()))
                .build()
                // TODO: There is a nicer way to handle errors: https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function
                .map_err(|err| MyError::DynamicMessage(err.to_string()))?; // Handle error from ActivityBuilder

            let reply = BotActivity::Message(my_message);

            // let abc = state.bot_api.directline.create_conversation().await?;


            state.bot_api
                .directline
                .reply_activity_with_auth(&body, &reply, &(*state.bot_api.access_token.lock().await).clone().unwrap())
                // .reply_activity(&body, &reply)
                .await
                .map_err(|err| MyError::DynamicMessage(format!("Send activity failed {}", err)))?;


            // let conv_access_response = state
            //     .bot_api
            //     .reconnect_conversation(&activity.conversation.id)
            //     .await?;

            // println!(
            //     "Conversation access token: {:?}",
            //     conv_access_response.token
            // );

            // let config = &state.config.teams;

            // let conf_xxx = state.bot_api.send_activity(&reply);

            // let reply_message =
            //     serde_json::to_value(&reply).map_err(|_| MyError::Message("Serialization"))?;

            Ok(warp::reply::with_status(
                warp::reply::json(&serde_json::json!({"message": "Message sent successfully"})),
                warp::http::StatusCode::CREATED,
            ))

            // Ok( reply_message)
        }
        BotActivity::Message(activity) => {
            info!("Activity: {:?}", activity);

            // let reply_url = activity
            //     .service_url
            //     .clone()
            //     .ok_or(MyError::AttributeNotFound("service_url"))?;

            let reply_url = activity
                .service_url.clone()
                .ok_or(MyError::AttributeNotFound("service_url"))?
                .join(format!("/v3/conversations/{}/activities", activity.conversation.id).as_str())
                .map_err(MyError::from)?;

            // reply_url.set_path(&format!(
            //     "/v3/conversations/{}/activities",
            //     activity.conversation.id
            // ));

            // let mut reply_url = activity
            //     .service_url
            //     .clone()
            //     .ok_or(MyError::AttributeNotFound("service_url"))?;

            println!("REPLY URL: {}", reply_url);


            // reply_url.set_path(&format!(
            //     "/v3/conversations/{}/activities",
            //     activity.conversation.id
            // ));
            // "/v3/conversations/{}/activities/{}", activity.conversation.id, activity.conversation.id));

            let my_message = MessageBuilder::default()
                // .channel_data(activity.channel_data.clone())
                .from(activity.recipient.clone())
                .recipient(activity.from.clone())
                .conversation(activity.conversation.clone())
                .text(format!("howdy: {}", activity.text))
                .reply_to_id(Some(activity.id.clone()))
                // .service_url(Some(state.config.teams.bot_endpoint.clone()))
                // .channel_id("emulator".to_owned())
                .locale(Some("en-US".to_owned()))
                // .input_hint(Some("acceptingInput".to_owned()))
                // .id(activity.id.clone())
                // .local_timestamp(Some("2025-04-26T22:39:03+01:00".to_owned()))
                // .timestamp("2025-04-26T22:39:03+01:00".to_owned())
                .build()
                // TODO: There is a nicer way to handle errors: https://docs.rs/derive_builder/latest/derive_builder/#error-return-type-from-autogenerated-build-function
                .map_err(|err| MyError::DynamicMessage(err.to_string()))?; // Handle error from ActivityBuilder

            let reply = BotActivity::Message(
                my_message, // .map_err(|_| MyError::Message("ActivityBuilder"))? // Handle error from ActivityBuilder
            );

            state.bot_api
                .directline
                .reply_activity(&body, &reply)
                .await
                .map_err(|err| MyError::DynamicMessage(format!("Send activity failed {}", err)))?;

            // state.bot_api.directline
            //     .send_activity(&reply)
            //     .await
            //     .map_err(|err| MyError::DynamicMessage(format!("Send activity failed {}", err)))?;

            // let xxx = state.bot_api.send_activity(&reply).await?;

            // info!("RESPONSE: {:?}", xxx);

            // let reply_message =
            //     serde_json::to_value(&reply).map_err(|_| MyError::Message("Serialization"))?;

            // todo!("Complete the reply_url path");
            Ok(warp::reply::with_status(
                warp::reply::json(&serde_json::json!({"message": "Message sent successfully"})),
                warp::http::StatusCode::CREATED,
            ))
        }
    }

    // println!("REPLY Message: {}", &reply_message.to_string());

    // // let reply_url = format!("{}/v3/conversations/{}/activities", service_url.trim_end_matches('/'), conversation_id);

    // let access_token_guard = state.teams.access_token.lock().await;
    // let access_token = access_token_guard
    //     .as_ref()
    //     .ok_or(MyError::AttributeNotFound("access_token"))?;

    // println!("Access token: {}", access_token);

    // let response = client
    //     .post(reply_url.clone())
    //     .bearer_auth(access_token)
    //     .json(&reply_message)
    //     .send()
    //     .await;

    // info!("RESPONSE: {} <= {:?}", reply_url, response);

    // return Ok(warp::reply::with_status(
    //     warp::reply::json(&serde_json::json!({"message": "Message sent successfully"})),
    //     warp::http::StatusCode::CREATED,
    // ));

    // match response {
    //     Ok(res) => {
    //         if res.status().is_success() {
    //             info!("Message sent successfully");
    //             Ok(warp::reply::with_status(
    //                 warp::reply::json(&serde_json::json!({"message": "Message sent successfully"})),
    //                 warp::http::StatusCode::CREATED,
    //             ))
    //             // Ok(warp::reply::json(&"Message sent successfully"))
    //         } else {
    //             error!("Failed to send message: {:?}", res);
    //             error!("BODY: {}", res.text().await.unwrap());
    //             Err(warp::reject::custom(MyError::Message("status fail")))
    //         }
    //     }
    //     Err(err) => {
    //         info!("Error sending message: {:?}", err);
    //         Err(warp::reject::custom(MyError::Message("Send failed")))
    //     }
    // }
}
